# GPG. Шифрование в линуксе. Лучшее из Open Source. // DEVPEW
Смотрите, сегодня мы будем говорить про шифрование.

Вообще у нас есть совсем небольшое количество программ, которым можно доверять шифровать свои данные.

Так, например, раньше была очень популярна программа для шифрования, которая называлась TrueCrypt. Она имела очень большое количество пользователей и этой программе доверяли.

Но в один момент с ней произошла очень интересная вещь. Эта вещь называется “Свидетельство канарейки”

Свидетельство канарейки
-----------------------

Этот термин произошел совсем недавно, когда шахтеры начали брать с собой канарейку при добыче угля. В шахтах большой риск отравиться угарным газом, а канарейка испытывала действие газа намного раньше человека и умолкала.

Фактически этот термин означает передачу информации через молчание или отрицание.

Примеры:

Согласно “Патриотическому акту”, правительство США может направить секретный ордер интернет-компании на слежку за пользователем. Закон запрещает компании разглашать факт слежки. Но некоторые компании могут отправить вам имейл: “Уважаемый юзер, уведомляем вас о том, что в период с 2008 года по 5 октября 2017 года за вами не велось скрытое наблюдение. С уважением”.

TrueCrypt до 2014 года был очень надежной программой для шифрования, а в 2014 году проект был закрыт из-за давления на разработчиков. Все старые версии удалены, репозиторий очищен. А разработчики настоятельно рекомендовали переходить на программу BitLocker. Все сообщество сразу поняло сообщение разработчиков без лишних слов, так как ранее они высмеивали безопасность BitL ocker, то есть намёк на неискренность собственных слов и попытку сказать нечто важное.

Как и всегда я рекомендую использовать для шифрования только ПО с открытым исходным кодом.

Один из самых классных проектов для шифрования данных это GPG. Про который я и буду рассказывать.

И ролик я думаю будет большим. И сначала я расскажу базовые вещи, чтобы каждый смог понимать о чем речь. А дальше буду уже показывать на практике как вообще все настраивать и шифровать данные.

Будет так же круто, если кто-то сделает комментарий с таймингами, я его закреплю первым.

Начали.

Симметричное и асимметричное шифрование
---------------------------------------

Для начала нужно понимать, что бывает два вида шифрования - Симметричное и асимметричное.

*   **Симметричное шифрование** использует один и тот же ключ и для зашифровывания, и для расшифровывания.
*   **Асимметричное шифрование** использует два разных ключа: один для зашифровывания (который также называется открытым), другой для расшифровывания (называется закрытым).

Эти методы решают определённые задачи и обладают как достоинствами, так и недостатками. Конкретный выбор применяемого метода зависит от целей, с которыми информация подвергается шифрованию.

### Симметричное шифрование

В **симметричных** криптосистемах Алгоритм и ключ выбирается заранее и известен обеим сторонам. Сохранение ключа в секретности является важной задачей для установления и поддержки защищённого канала связи. В связи с этим, возникает проблема начальной передачи ключа (синхронизации ключей).

Симметричные, а конкретнее, алфавитные алгоритмы шифрования были одними из первых алгоритмов. Позднее было изобретено асимметричное шифрование, в котором ключи у собеседников разные.

Самые популярные алгоритмы: AES, Blowfish, Twofish.

### Недостатки

Недостатками симметричного шифрования является проблема передачи ключа собеседнику и невозможность установить подлинность или авторство текста. Поэтому, например, в основе технологии цифровой подписи лежат асимметричные схемы. В остальном же алгоритм симметричного шифрования можно считать достаточно проработанным и эффективным, с минимальным количеством недостатков, особенно на фоне асимметричного шифрования

### Достоинства:

*   скорость
*   простота реализации (за счёт более простых операций)
*   меньшая требуемая длина ключа для сопоставимой стойкости
*   изученность (за счёт большего возраста)

### Асимметричное шифрование

Как уже было сказано, достоинство в том, что вы можете свой публичный ключ отдать через незащищенный канал. Так как этим ключом человек сможет только шифровать что-то. Но не сможет расшифровывать.

Криптографические системы с открытым ключом в настоящее время широко применяются в различных сетевых протоколах: TLS, SSL, HTTPS, SSH, PGP.

Первый недостаток асимметричного шифрования заключается в низкой скорости выполнения операций зашифровки и расшифровки, что обусловлено необходимостью обработки ресурсоемких операций. Как следствие, требования к аппаратной составляющей такой системы часто бывают неприемлемы.

Вообще принцип асимметричного шифрования можно очень просто выразить одной фразой: “Можно сгенерировать пару очень больших чисел так, чтобы, зная одно, нельзя было вычислить другое за разумный срок. При этом механизм генерации является общеизвестным.”

Все асимметричные алгоритмы можно описать очень кратко. Должно быть всего одно свойство. Если известно `x` то `f(x)` вычислить довольно просто. Если известно `y=f(x)`, то для вычисления `x` нет простого пути.

Один из самых популярных алгоритмов является алгоритм **RSA**

RSA (Алгоритм работы)
---------------------

Алгоритм работает довольно просто. Мы просто берем два простых числа `P` и `Q`.

Умножим их друг на друга и в результате получим `N`.

Потом выберем случайное число `D`. Оно должно быть взаимно простым с `(P-1)*(Q-1)`.

И определим число `E`, для которого будет истиной `(E*D) mod ((P-1)*(Q-1))=1`

И у нас открытый ключ это числа `E` и `N`, а приватный - числа `D` и `N`

Теперь, чтоб нам зашифровать что-нибудь нашим открытым ключом `{E,N}` нам надо разбить наш шифруемый текст на блоки, каждый из которых можно представить в виде числа `M(I)=0,1,2..., N-1`

И зашифровать, как последовательность `M(I)` по формуле `C(I)=(M(I)^e)mod N`.

А чтобы потом расшифровать это, просто используем секретный ключ `{D,N}`, по формуле `M(I) = (C(I)^D) mod N`

В результате получим исходный текст.

Алгоритм RSA он один, но мы можем использовать ключ разной длины. Когда ты создаешь RSA пару, то ты указываешь длину ключа в битах. Эта длина определяет количество бит в модуле.

Короче, для того чтобы хранить ваши данные в безопасности в течение двух десятилетий рекомендуется использовать RSA2048.

Два десятилетия это потому, что у нас до сих пор существует закон Мура. Некоторые говорят, что он уже не работает, вроде это говорил директор NVidia. Но не знаю откуда у него такая информация. По информации всех остальных людей в этом мире закон Мура работает и будет работать дальше.

И фактически сейчас взломать RSA2048 невозможно. Но через 20 лет это будет возможно.

Вы можете спросить, а почему не взять просто самый большой из возможных.

И с точки зрения безопасности естественно лучше выбирать тот, который больше. Так как он будет наиболее безопасным. И причем тут зависимость не линейная.

То есть 2048 не в 2 раза безопаснее чем 1024. А во много раз. И так же 4096 во много раз безопаснее чем 2048.

Но при этом сам процесс шифрования и процесс расшифровки он у нас естественно требует нашего с вами процессорного времени. И тут тоже большая разница. Каждое увеличение ключа в два раза увеличивает процессорное время примерно в 6-7 раз. Ну вот условно если ваш процессор будет расшифровывать rsa1024 одну минуту. То rsa2048 он будет расшифровывать 7 минут. А RSA4096 он уже будет расшифровывать 49 минут.

![img](https://devpew.com/blog/gpg/RSADecryptionTime.png)

Насколько безопасен каждый из вариантов?
----------------------------------------

[https://ru.wikipedia.org/wiki/RSA-](https://ru.wikipedia.org/wiki/RSA-)числа

**RSA-числа** - это множество больших полупростых чисел (чисел, представимых в виде произведения двух простых чисел), используемых в конкурсе RSA Factoring Challenge. Конкурс заключался в нахождении простых множителей предложенных чисел

RSA Laboratories опубликовала 54 полупростых числа длиной от 100 до 617 десятичных знаков. За факторизацию некоторых из них были предложены денежные призы. Наименьшее RSA-число было разложено за несколько дней. Большинство чисел до сих пор не разложены и предполагается, что многие из них останутся неразложенными ещё довольно долгое время.

RSA Challenge официально закончился в 2007 году, но люди до сих пор пытаются раскладывать числа, к марту 2017 года было разложено 19 из 54 чисел. Первые RSA-числа, от RSA-100 до RSA-500, были пронумерованы в соответствии с числом десятичных знаков. Более поздняя нумерация отражает число битов

**RSA-230** имеет 230 десятичных знаков (762 бита). Факторизовано 15 августа 2018 в Noblis

**RSA-232** имеет 232 десятичных знака (768 бит), и пока что не факторизовано

**RSA-768** имеет 768 бит (232 десятичных знака) и было разложено 12 декабря 2009 года Торстеном Клейнжунгом, Казумаро Аоки, Йенсом Франке, Арьеном Ленстрой, Эммануилом Томе, П. Годри, Александром Круппа, Питером Монтгомери, Д. В. Босом, Д. А. Освиком, Г. Рилем, Андреем Тимофеевым и Полем Циммерманном.

**RSA-1024** имеет 1024 бита (309 десятичных знаков), и пока что не факторизовано. За факторизацию был объявлен денежный приз в 100000 долларов США.

Успешная факторизация RSA-1024 имеет важное значение для многих пользователей алгоритма RSA аутентификации с открытым ключом, т.к. наиболее часто используемая длина ключа — 1024 бита.

**RSA-2048** имеет 2048 битов (617 десятичных знаков). Это наибольшее из RSA-чисел и за него положен приз в 200000 долларов США.

Наибольшее факторизованное RSA-число имеет длину 768 бит (232 десятичных знака) и RSA-2048 может не быть разложено в течение долгих лет, до значительного улучшения вычислительных мощностей и продвижений в факторизации целых чисел.

AHTUNG! Биты!
-------------

Важно понимать одну вещь!

RSA Security рекомендует использовать ключи 2048 бит, когда большинство алгоритмов симметричного шифрования используют 112 или 256 бит.

Почему?

Тут прям принципиальная разница. Для того чтобы взломать RSA нужно найти сомножитель определенной длины. И это такая задача, которую нельзя усложнить очень сильно, иначе для зашифровки и расшифровки у нас будет требоваться очень много времени.

А чтобы взломать симметричный ключ нам надо перебрать 2 в степени N комбинаций, где N — длина ключа. И имея симметричный ключ у нас как шифрование так и расшифровка делается прям мгновенно.

Так что симметричный ключ в 256 бит примерно равен ассиметричному ключу в 15360 бит.

ПРАКТИКА
--------

Ладно, давайте уже перейдем к практике.

Для шифрования мы будем использовать пакет `gpg` это программа для асимметричного шифрования с открытым кодом, которая очень популярна. С помощью нее вы можете шифровать данные, подписывать свои файлы.

Подпись нужна для того чтобы в сети знали, что это вы. Программисты, например, часто используют `gpg` для того чтобы подписывать им свои программы. Просто чтобы вы были уверены, что программа именно от программиста, а не кто-то внедрил в программу вирус и подменил файл.

Или, например, создатель биткоина писал сообщения сообществу и подписывал их своим ключом.

Мы все знаем что его ключ

```
pub 1024D/5EC948A1 2008-10-30

```


И если мы видим такую подпись, то мы скорее будем доверять ей. Чем какому-то сообщению без подписи.

Так же с помощью `gpg` мы можем авторизоваться на SSH серверах.

Короче говоря, очень крутая программа, которой пользуются просто все. Вы если про нее не знаете, то рекомендую узнать о ней побольше.

Как я уже сказал, она может шифровать, подписывать и авторизовывать.

Давайте же начнем ее использовать.

Для начала установим пакет `gpg`

Проверим, что версия актуальная.

```
gpg --version

```


У меня, например версия 2.2.13.

Давайте проверим так же, что у нас нет ключей. Я свои удалил, чтобы показать вам весь процесс создания ключей с самого начала.

Для того чтобы посмотреть наши публичные ключи есть команда

```
gpg -k

```


`gpg --list-keys --keyid-format LONG` (Мы так же можем использовать эту команду если нам нужно видеть ключи)

А для того чтобы увидеть приватные ключи есть команда:

```
gpg -K

```


`gpg --list-secret-keys --keyid-format LONG` (Мы так же можем использовать эту команду если нам нужно видеть ключи)

Мы убедились, что у нас нет ключей. Теперь давайте мы их создадим. Делается это командой:

```
gpg --full-generate-key

```


Как я уже говорил, мы можем выбрать любой из вариантов. RSA Lab нам рекомендует `2048`. Лично я выберу `4096`, если ваш компьютер мощный, то я и вам его рекомендую.

Так, теперь мы можем опять выполнить команды `gpg -k` и `gpg -K`

И теперь мы видим, что у нас есть наш ключ.

Давайте теперь я кратко расскажу о том, как это читается.

```
sec  2048R/920B1221 2013-12-01 [expires: 2014-12-01]

```


*   `sec` – это primary private часть нашего ключа
*   `4096R` – это собственно алгоритм и количество бит
*   `920B1221` – это айди ключа, ну вернее последняя его часть, на самом деле он немного длиннее.
*   `2013-12-01` – дата создания ключа
*   `[expires: 2014-12-01]` – когда истекает ключ

uid

*   `uid` – это что-то вроде идентификатора
*   `Dmitriy Kovalev` – Это имя, которое мы задавали
*   `123` – Это наш комментарий
*   \`\` – имейл

```
ssb  2048R/2AB141A0 2013-12-01

```


*   `ssb` – Это наш сабкей в приватной части нашего ключа
*   `2048R` – его алгоритм
*   `2AB141A0` – его айди
*   `2013-12-01` – его дата создания

Когда мы создаем наш ключ, то это вообще все сохраняется в директории `~/.gnupg`

*   `~/.gnupg/gpg.conf` - файл конфиругации
*   `~/.gnupg/secring.gpg` - тут секретная часть ключей
*   `~/.gnupg/pubring.gpg` - тут приватная часть ключей

Sign
----

Теперь смотрите, мы можем взять какой-нибудь файл и подписать его с помощью команды

```
gpg --clearsign 1.txt

```


Давайте теперь откроем файл и посмотрим на него.

![img](https://devpew.com/blog/gpg/2019-03-16-18-12-53.png)

Encrypt
-------

Теперь давайте попробуем зашифровать какой-нибудь файл.

```
gpg -r johenews --armor --encrypt 1.txt

```


Теперь откроем его.

![img](https://devpew.com/blog/gpg/2019-03-16-18-14-18.png)

Видим, что файл зашифрован.

А теперь расшифруем его.

```
gpg -d 1.txt.asc

```


![img](https://devpew.com/blog/gpg/2019-03-16-18-14-57.png)

Ну, вот как-то так.

Just a test
-----------

Давайте теперь попробуем зашифровать какой-нибудь прям огромный файл.

Давайте, например, возьмем 100 гигабайт.

```
dd of=file.txt bs=1 count=0 seek=100G

```


Теперь зашифруем его

```
gpg -r johenews --armor --encrypt file.txt

```


А теперь расшифруем

```
gpg -d file.txt.asc

```


Результат теста с ключом в 4096 бит следующий

> шифрование 100gb файла =

> расшифровка 100gb файла =

Этот пример я показал вам для того, чтобы вы понимали, что асимметричное шифрование не очень хорошо подходит для того, чтобы шифровать очень большие файлы. Тест мой сделан на ноутбуке Lenovo x1c6. На вашем компьютере время будет другим.

Так же надо понимать, что это время для `4096`. На `2048` все будет в 6-7 раз быстрее. А на `1024` все будет в 40-50 раз быстрее.

Это я вам показал самые основы.

Теперь давайте поговорим подробнее про ключи. Так как это крайне важно.

Keys
----

Ваш ключ может использоваться для защиты ваших важных данных. Я вот рассказывал уже про менеджер паролей [pass](https://devpew.com/password-managers/). Он как раз использует ключ `gpg`. Так же как я уже сказал вы можете привязать ключи к вашему SSH серверу и заходить на него с их помощью. И если злоумышленник получит ваши ключи, то будет совсем печально, поэтому надо со всей ответственностью подойти к безопасности и о правильном их хранении.

Хорошей практикой считается отдельное хранение основного приватного ключа.

Для этого мы сейчас создадим саб-ключи. А основной ключ сначала забэкапим, потом закачаем его в самое безопасное место и потом удалим из `pgp`.

А делается это потому, что наш главный ключ умеет создавать саб ключи. И саб ключа нам достаточно для всего.

Главным ключом мы можем создать саб-ключ на небольшой промежуток времени. И чисто теоретически, даже если у вас украдут ноутбук, то ваш ключ не будет скомпрометирован. С помощью основного ключа вы сможете отозвать тот ключ и создать новый.

Добавим subkeys
---------------

Делается это командой

```
gpg --expert --edit-key johenews

```


После нее мы входим в консоль `gpg` и далее мы можем там вводить команды. Для того чтобы посмотреть список всех команд мы можем ввести `?`

Чтобы добавить новые subkey мы должны ввести

```
addkey

```


Создать ключ и потом не забываем написать

```
save

```


Бэкапим секретный ключ
----------------------

```
gpg -a --export-secret-key johenews > secret_key

```


Создаем Revocation Certificate
------------------------------

```
gpg -a --gen-revoke johenews > revocation_cert.gpg

```


Экспортируем публичный ключ
---------------------------

```
gpg -a --export johenews > public_key.gpg

```


Очень важно хранить секретный ключ в супернадежном месте.

revocation certificate тоже важно хранить где-либо куда никто кроме вас не имеет доступ.

Удаляем Primary Key
-------------------

Для начала мы должны экспортировать secret subkeys:

```
gpg -a --export-secret-subkeys johenews > secret_subs.gpg

```


Теперь удалим всю секретную часть нашего ключа:

```
gpg --delete-secret-keys johenews

```


При этом надо понимать, что у нас останется публичная часть нашего ключа в `~/.gnupg/pubring.gpg`:

```
gpg -k

```


Но не будет ничего в `~/.gnupg/secring.gpg`:

```
gpg -K

```


Теперь мы должны будем сделать импорт наших приватных саб-ключей, но без главного ключа:

```
gpg --import secret_subs.gpg

```


And we’re left with our “laptop keys”:

```
gpg -k
gpg -K

```


Надо понимать, что знак `#` рядом с `sec` означает что primary часть секретного ключа отсутствует в нашей связке ключей.

Теперь мы можем записать primary часть секретного ключа, например на Yubikey или другой ключ. Если у нас его нет, то просто копируем на флэшку и прячем ее в самое секретное место в мире.

```
gpg -a --export-secret-keys johenews > laptop_keys_secret.gpg
gpg -a --export johenews > laptop_keys_public.gpg

```


И теперь мы можем импортировать их на наш другой наш компьютер:

```
gpg --import laptop_keys_public.gpg

```


The end
-------

Если эта тема будет интересна, то в следующий раз расскажу о том как авторизовываться на SSH с помощью gpg , как закачать ключ на Yubikey, как шифровать email переписку.